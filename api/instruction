------------------
-- Dependencies --
------------------
assert(os.loadAPI("api/util"), "Required API missing: util")
-- Optional
os.loadAPI("api/tapi")
os.loadAPI("api/treefarmapi")
local tf = treefarmapi


-----------------------
-- Instruction class --
-----------------------
local Instruction = {
  Type = "generic_instruction",
  instruction = nil,
  arg = nil,
  line = nil
}

function Instruction:new(obj)
  obj = obj or {}  
  setmetatable(obj, self)
  self.__index = self
  
  return obj
end

function Instruction:execute()
  return self:validate()
end

function Instruction:validate()
  print("Generic instructions not allowed")
  print("Type: "..tostring(self.Type))
  print("Instruction: "..tostring(self.instruction))
  print("Arg: "..tostring(self.arg))
  return false -- Generic instructions are not allowed
end

function Instruction:setLineNumber(n)
  self.lineNumber = n
end

function Instruction:getLineNumber()
  return self.lineNumber
end

function Instruction:convertArguments()
  return true
end

function Instruction:getRelativeJumpLocation()
  -- Most instructions will return 1, meaning go to the
  -- next instruction
  return 1
end

NopInstruction = Instruction:new({Type = "nop_instruction"})
function NopInstruction:validate()
  return true
end

function NopInstruction:execute()
  return true
end

TurtleInstruction = Instruction:new({
  Type = "turtle_instruction",
  Instructions = {
    "forward",
    "back",
    "backward",
    "left",
    "right",
    "up",
    "down",
    "dig",
    "digUp",
    "digDown",
    "place",
    "placeUp",
    "placeDown",
    "suck",
    "suckUp",
    "suckDown",
    
    "harvestTree",
    "plantSapling"
  }
})

function TurtleInstruction:isDirection()
  local instruction = self.instruction
  return instruction == "forward" or
         instruction == "back" or
         instruction == "backward" or
         instruction == "left" or
         instruction == "right" or
         instruction == "up" or
         instruction == "down"
end

-- function TurtleInstruction:isTreeInstruction()
-- end

function TurtleInstruction:convertArguments()
  assert(tapi, "Missing tapi")
  local instruction = self.instruction
  if self:isDirection() then
    if not self.arg then self.arg = 1
    else self.arg = tonumber(self.arg)
    end
    return type(self.arg) == "number"
  elseif instruction == "harvestTree" then
    assert(tf, "Missing treefarmerapi")
    if not self.arg then self.arg = tf.MAX_HEIGHT
    else self.arg = tonumber(self.arg) 
    end
    return type(self.arg) == "number"
  end
  return true
end

function TurtleInstruction:validate()
  assert(tapi, "Missing tapi")
  local instruction = self.instruction
  local arg = self.arg
  if self:isDirection() or 
     instruction == "harvestTree" then
    if type(arg) ~= "number" then return false end
    return true
  elseif instruction == "dig" or
         instruction == "digUp" or
         instruction == "digDown" or
         instruction == "place" or
         instruction == "placeUp" or
         instruction == "placeDown" or
         instruction == "suck" or
         instruction == "suckUp" or
         instruction == "suckDown" or
         instruction == "plantSapling" then
    if arg then return false end
    return true
  else
    print("Instruction not recognized")
    return false
  end    
end

function TurtleInstruction:execute()
  assert(tapi, "Missing tapi")
  local instruction = self.instruction
  local arg = self.arg
  print(tostring(instruction).." "..tostring(arg))
  if self:isDirection() then
    if type(arg) ~= "number" then return false end
    return tapi.go(instruction, arg)
  elseif instruction == "dig" or
         instruction == "digUp" or
         instruction == "digDown" or
         instruction == "place" or
         instruction == "placeUp" or
         instruction == "placeDown" or
         instruction == "suck" or
         instruction == "suckUp" or
         instruction == "suckDown" then
    if arg then return false end
    return true
  elseif instruction == "harvestTree" then
    assert(tf, "Missing treefarmerapi")
    if type(arg) ~= "number" then return false end
    tf.tryHarvestTree()
    return true -- Return true whether we were able to harvest or not
  elseif instruction == "plantSapling" then
    assert(tf, "Missing treefarmerapi")
    if arg then return false end
    tf.plantSapling()
    return true -- Return true whether we placed a sapling or not
  else
    print("Instruction not recognized")
    return false
  end    
end

ControlInstruction = Instruction:new({
  Type = "control_instruction",
  Instructions = {
    "loop",
    "loopend",
    "jump"
  }
})

function ControlInstruction:validate()
  local instruction = self.instruction
  local arg = self.arg
  if instruction == "loop" then
    if not arg then return false end
    
    loopCount = arg
    if loopCount then return true
    else return false
    end
  elseif instruction == "loopend" then
    if arg then return false
    else return true
    end
  elseif instruction == "jump" then
    if type(self["target"]) ~= "number" or
       type(self["count"]) ~= "number"  or
       self["count"] < 0 then return false end
    return true
  else
    -- Note: Jump instructions private for now
    return false
  end
end

function ControlInstruction:execute()
  local instruction = self.instruction
  if instruction == "jump" then
    if self.count > 0 then
      self.count = self.count - 1
    end
    return true
  end
  return false
end

function ControlInstruction:getRelativeJumpLocation()
  local instruction = self.instruction
  local arg = self.arg
  if instruction == "jump" then
    if self.count > 0 then return self.target end
    return 1
  end
  return Instruction:getRelativeJumpLocation()
end