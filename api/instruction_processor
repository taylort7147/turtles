------------------
-- Dependencies --
------------------
assert(os.loadAPI("api/instruction"), "Required API missing: instruction")
local Instruction = instruction.Instruction
local TurtleInstruction = instruction.TurtleInstruction
local ControlInstruction = instruction. ControlInstruction
local NopInstruction = instruction.NopInstruction
assert(os.loadAPI("api/data_struct"), "Required API missing: data_struct")
local Stack = data_struct.Stack
local Queue = data_struct.Queue
assert(os.loadAPI("api/util"), "Required API missing: util")


function parseLine(line)
  if type(line) ~= "string" then return end
  tokens = util.split(line)
  local inst = tokens[1]
  local arg = tokens[2]
  
  if not inst then
    return NopInstruction:new()
  elseif util.contains(TurtleInstruction.Instructions, inst) then
    return TurtleInstruction:new({instruction=inst, arg=arg})
  elseif util.contains(ControlInstruction.Instructions, inst) then
    return ControlInstruction:new({instruction=inst, arg=arg})
  else
    print("Instruction \""..tostring(inst).."\" not recognized")
  end
end  
  

function parseFile(filename)
  if type(filename) ~= "string" then 
    print("Expected string, got "..type(filename))
    return 
  end
  
  local fh = io.open(filename, "r")
  if not fh then 
    print("Failed to open "..filename)
    return 
  end
  
  -- Parse each line
  local queue = Queue:new()
  local line = fh:read("*l")
  local lineNum = 1
  while line do
    local instruction = parseLine(line)
    if not instruction then 
      print("Parsing error ["..filename..":"..tostring(lineNum).."]")
      return
    end
    
    if not instruction:convertArguments() and instruction:validate() then
      print("Invalid instruction ["..filename..":"..tostring(lineNum).."]")
      print("Type: "..tostring(instruction.Type))
      print("Instruction: "..tostring(instruction.instruction))
      print("Arg: "..tostring(instruction.arg))
      return
    end
    instruction:setLineNumber(lineNum)
    queue:put(instruction)
    lineNum = lineNum + 1
    line = fh:read("*l")
  end
  
  return queue
end

function compileInstructions(instructionQueue)
  local iq = instructionQueue
  local stack = Stack:new()
  local currIndex = 1
  local lastLoopStartIndex = nil
  local lastLoopInstruction = nil
  local lastLoopCount = nil
  
  while not iq:empty() do
    local inst = iq:get()

    if not inst then 
      print("Unexpected nil instruction")
      return
    end
    
    if inst.Type == ControlInstruction.Type then
      if inst.instruction == "loop" then
        lastLoopCount = tonumber(inst.arg)
        
        -- Make sure there are no unresolved loops so far
        if lastLoopInstruction ~= nil then
          print("Expected \"loopend\" at line "..
            tostring(inst:getLineNumber())..
            " for loop starting at line "..
            tostring(lastLoopInstruction:getLineNumber()))
          return
        end
        
        -- Record current loop start for later use
        lastLoopStartIndex = currIndex        
        print("Setting start: "..tostring(lastLoopStartIndex))
        lastLoopInstruction = inst 
        
        -- Note: We don't actually add our loop instruction
        --       to the stack
        
      elseif inst.instruction == "loopend" then
        -- Make sure we have a corresponding loop start
        if not lastLoopStartIndex or not lastLoopInstruction then
          print("Expected \"loop\" for \"loopend\" at line "..
            tostring(inst:getLineNumber()))
          return
        end
        
        -- Convert loop end into jump instruction to add to
        -- the stack.
        print("Curr: "..tostring(currIndex))
        print("Last: "..tostring(lastLoopStartIndex))
        local jumpTarget = lastLoopStartIndex - currIndex
        if jumpTarget >= 0 then
          print("Expected jump target to be negative, but got: "..
            tostring(jumpTarget))
          return
        end
        jumpInstruction = ControlInstruction:new({instruction="jump", target=jumpTarget, count=lastLoopCount})
        stack:push(jumpInstruction)
        currIndex = currIndex + 1
        
        -- Reset last loop start variables
        lastLoopStartIndex = nil
        lastLoopInstruction = nil
        lastLoopCount = nil
      else
        print("Unsupported control instruction at line "..
          tostring(inst:getLineNumber())..": "..
          tostring(inst.instruction))
        return
      end
    elseif inst.Type == TurtleInstruction.Type then
      stack:push(inst)
      currIndex = currIndex + 1
    else
    end
  end
  
  return stack:getTable()
end

function executeInstructions(t)
  assert(type(t) == "table")
  local index = 1
  while true do
    if index > table.maxn(t) then return true end
    
    -- print(index)
    -- print(t[index])
    -- print(t[index].instruction)
    -- Execute instruction
    if not t[index]:execute() then
      print("An error occurred while executing instruction at index "..
        tostring(index))
      return false
    end
    -- Get next index
    index = index + t[index]:getRelativeJumpLocation()    
  end
end