-----------------------
--    Service API    --
-----------------------
os.loadAPI("api/tapi")

-----------------
-- Constants
-----------------
DEFAULT_PROTOCOL = "default"

----------------------
-- Static functions --
----------------------

-- Serializes an object into a string that can be
-- deserialized using the deserialize function.
function serialize(obj)
  local str = ""
  if type(obj) == "table" then
    str = "{"
    for k, v in pairs(obj) do
      if type(k) ~= "number" then
        k = serialize(k)
      end
      str = str..k..":"..serialize(v)..","
    end
    return str.."}"
  else
    return textutils.serialise(obj)
  end
end

-- Deserializes a string that was generated using the
-- serialize function and returns the deserialized object.
function deserialize(str)
  tokens = tokenize(str)
  return resolveTokens(tokens)
end

-----------------
-- Token class --
-----------------
function Token(type, value, customSize)
  if customSize == nil then customSize = value:len() end
  local self = {
    type = type,
    value = value,
    size = customSize
  }
  
  -- Returns the amount of characters this token represents
  -- (when used during the tokenization phase)
  function self.len()
    return self.size
  end

  -- Returns a string representation of this token in the
  -- form:
  --  (type, value)
  function self.str()
    return "("..self.type..","..tostring(self.value)..")"
  end
  
  -- Parses the string value and returns the object it
  -- represents.
  function self.parseValue()
    if self.type == "number" then
      return tonumber(self.value)
    elseif self.type == "string" then
      str = textutils.unserialise(self.value)
      return str
    else
      return self.value
    end
  end
  
  return self
end

-- Resolves a stream of tokens into an object
function resolveTokens(tokens)
  local i = 1
  local stack = {}
  while i <= table.maxn(tokens) do
    local token = tokens[i]
    
    -- Most tokens will just get pushed to the stack.
    -- Once we hit an rbrace we can resolve the current
    -- stack into a table and push that to the stack. 
    -- If there is no rbrace, the final object is assumed 
    -- to be a primative, in which case we can just pop
    -- it off at the end.
    if token.type == "lbrace" then
      table.insert(stack, token)
    elseif token.type == "number" then
      table.insert(stack, token)
    elseif token.type == "string" then
      table.insert(stack, token)
    elseif token.type == "colon" then
      table.insert(stack, token)
    elseif token.type == "rbrace" then
      local obj = {}
      local curr = table.remove(stack)
      
      -- Pop tokens and resolve until we hit the matching 
      -- lbrace.
      while curr and curr.type ~= "lbrace" do
          -- Check if the next token is a colon. If so, we
          -- must resolve the key-value pair it defines.
          nextToken = table.remove(stack)
          if nextToken and nextToken.type == "colon" then
            -- Add the value to the object at the key
            key = table.remove(stack)
            obj[key.parseValue()] = curr.parseValue()
          else
            -- Otherwise add the token back to the stack
            table.insert(stack, nextToken)
            
            -- Add the value to the object
            table.insert(obj, curr.parseValue())
        end
        -- Pop the next token
        curr = table.remove(stack)
      end
      tableToken = Token("table", obj, 0)
      table.insert(stack, tableToken)
    end
    i = i + 1
  end
  
  -- There should be exactly one token remaining in the stack which holds the
  -- resolved value.
  assert(table.maxn(stack) == 1, "Unable to resolve the tokens to a single object")
  return stack[1].parseValue()
end

-- Convert a string into a stream of tokens.
function tokenize(str)
  local tokens = {}
  while str:len() > 0 do
    -- print(str)
    local token = getNextToken(str)
    -- print(token)
    assert(token)
    -- print(token.value)
    if token.type == "separator" or 
       token.type == "whitespace" then
      -- Nothing to do
    else
      table.insert(tokens, token)
    end
    str = str:sub(token.len() + 1)
  end
  return tokens
end

-- Get the next token in a string.
function getNextToken(str)
  local m 
  local substitutions = 0
  local temp = 0
  m = str:match("^%s+")
  if m then return Token("whitespace", m) end
  m = str:match("^,")
  if m then return Token("separator", m) end
  m = str:match("^{")
  if m then return Token("lbrace", m) end
  m = str:match("^}")
  if m then return Token("rbrace", m) end
  m = str:match("^:")
  if m then return Token("colon", m) end
  m = str:match("^%d+")
  if m then return Token("number", m) end
  m = str:match('^"')
  if m then
    local i = 2
    while i <= str:len() do
      c = str:sub(i, i)
      if c == "\\" then i = i +1 end
      if c == "\"" then break end
      i = i + 1
    end
    m = str:sub(1, i)
    return Token("string", m) 
  end
end