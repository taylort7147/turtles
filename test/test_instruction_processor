assert(os.loadAPI("api/instruction_processor"), "Required API missing: instruction_processor")
local ip = instruction_processor
assert(os.loadAPI("api/instruction"), "Required API missing: instruction")
assert(os.loadAPI("api/test"), "Required API missing: test")

-- Constants
local VALID_ROUTINE_FILENAME = "test/test_files/valid_routine"


-- parseLine
local function testParseLineEmptyString()
  local str = ""
  local inst = ip.parseLine(str)
  test.assertNotNil(inst)
  test.assertAreEqual(instruction.NopInstruction.Type, inst.Type)
  test.assertNil(inst.instruction)
  test.assertNil(inst.arg)
end

local function testParseLineTurtleInstructionNoArgs()
  local str = "back"
  local inst = ip.parseLine(str)
  test.assertNotNil(inst)
  test.assertAreEqual(instruction.TurtleInstruction.Type, inst.Type)
  test.assertAreEqual("back", inst.instruction)
  test.assertNil(inst.arg)
end

local function testParseLineTurtleInstructionWithArgs()
  local str = "placeDown minecraft:sapling"
  local inst = ip.parseLine(str)
  test.assertNotNil(inst)
  test.assertAreEqual(instruction.TurtleInstruction.Type, inst.Type)
  test.assertAreEqual("placeDown", inst.instruction)
  test.assertAreEqual("minecraft:sapling", inst.arg)
end

local function testParseLineControlInstruction()
  local str = "loop 9"
  local inst = ip.parseLine(str)
  test.assertNotNil(inst)
  test.assertAreEqual(instruction.ControlInstruction.Type, inst.Type)
  test.assertAreEqual("loop", inst.instruction)
  test.assertAreEqual("9", inst.arg)
end


-- parseFile
local function testParseFileValidRoutine()
  local q = ip.parseFile(VALID_ROUTINE_FILENAME)
  test.assertNotNil(q)
  local inst = q:get()
  test.assertAreEqual("dig", inst.instruction)
  test.assertAreEqual(1, inst:getLineNumber())
  inst = q:get()
  test.assertAreEqual("left", inst.instruction)
  test.assertAreEqual(2, inst:getLineNumber())
  inst = q:get()
  test.assertAreEqual("forward", inst.instruction)
  test.assertAreEqual(3, inst:getLineNumber())
  inst = q:get()
  test.assertAreEqual("up", inst.instruction)
  test.assertAreEqual(4, inst:getLineNumber())
  inst = q:get()
  test.assertAreEqual("loop", inst.instruction)
  test.assertAreEqual("10", inst.arg)
  test.assertAreEqual(5, inst:getLineNumber())
  inst = q:get()
  test.assertAreEqual("back", inst.instruction)
  test.assertAreEqual(6, inst:getLineNumber())
  inst = q:get()
  test.assertAreEqual("loopend", inst.instruction)
  test.assertAreEqual(7, inst:getLineNumber())
end

-- compileInstructions
local function testCompileInstructionsHappyPath()
  local iq = ip.parseFile(VALID_ROUTINE_FILENAME)
  c = ip.compileInstructions(iq)
  
  test.assertAreEqual("dig", c[1].instruction)
  test.assertAreEqual("left", c[2].instruction)
  test.assertAreEqual("forward", c[3].instruction)
  test.assertAreEqual("up", c[4].instruction)
  test.assertAreEqual("back", c[5].instruction)
  test.assertAreEqual("jump", c[6].instruction)
  test.assertAreEqual(-1, c[6].arg)
end


-- Run tests
print("Running parseLine() tests")
testParseLineEmptyString()
testParseLineTurtleInstructionNoArgs()
testParseLineTurtleInstructionWithArgs()
testParseLineControlInstruction()

print("Running parseFile() tests")
testParseFileValidRoutine()

print("Running compileInstructions() tests")
testCompileInstructionsHappyPath()


print("Success")